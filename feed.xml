<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
	<channel>
		<title><![CDATA[Development Experiences]]></title>
		<description><![CDATA[Development Experiences]]></description>
		<link>http://github.com/dylang/node-rss</link>
		<image>
			<url>https://code-chris.github.io/favicon.ico</url>
			<title>Development Experiences</title>
			<link></link>
		</image>
		<generator>RSS for Node</generator>
		<lastBuildDate>Tue, 09 Jan 2018 09:38:57 GMT</lastBuildDate>
		<atom:link href="https://code-chris.github.io/feed.xml" rel="self" type="application/rss+xml"/>
		<pubDate>Tue, 09 Jan 2018 09:38:57 GMT</pubDate>
		<managingEditor><![CDATA[Christian Kotzbauer]]></managingEditor>
		<item>
			<title><![CDATA[Cache-Busting with Webpack]]></title>
			<description><![CDATA[<html><head></head><body>


<p>There are several strategies to implement a caching mechanism. The common way with Webpack is, to change the file
name and add a content-based hash. The advantage of this is, that the file only needs to be reloaded if its content
changed. But the disadvantage is (e.g. for Images) that all references in your Source code have to be modified in
order to match the different file names. Last year, I implemented a Webpack plugin which does the job. See my previous post:
<a href="https://code-chris.github.io/posts/2016/10/long-term-caching-of-webpack-assets/index.html">&quot;Long-term caching of Webpack Assets&quot;</a>
This worked great until you start generating some paths through variables at runtime. So I reconsidered my strategy.
The result was the usage of a fairly old mechanism: Cache-Busting with a Query-Parameter. To append this parameter
to all the code references, I wrote a custom Webpack Loader.</p>
<p>First, install the loader through npm:</p>
<pre><code>npm install cache-bust-loader
</code></pre>
<p>Assuming, that the list of loaders in your <code>webpack.config.js</code> looks similar to this:</p>
<pre><code class="language-js">[
    { test: /\.css$/, loader: ExtractTextPlugin.extract({ loader: &quot;css-loader&quot; }) },
    { test: /\.html$/, loader: &quot;raw-loader&quot; },
    { test: /\.ts$/, loader: &quot;awesome-typescript-loader&quot; }
]
</code></pre>
<p>Now, simply add the <code>cache-bust-loader</code> to each file-type where you reference other files which you want to be cache-busted:</p>
<pre><code class="language-js">var cacheBustLoader = `cache-bust-loader?name=bust&amp;value=${bustValue}`;

[
    { test: /\.css$/, loader: ExtractTextPlugin.extract({ loader: `${cacheBustLoader}!css-loader` }) },
    { test: /\.html$/, loader: `${cacheBustLoader}!raw-loader` },
    { test: /\.ts$/, loader: `${cacheBustLoader}!awesome-typescript-loader` }
]
</code></pre>
<p>The loader has three parameters:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Mandatory</th>
<th>Data type</th>
<th>Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>True</td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td>False</td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>types</td>
<td>False</td>
<td>String</td>
<td>eot;woff;woff2;svg;ttf;otf;jpg;jpeg;png;ico;gif;json</td>
</tr>
</tbody>
</table>
<p>The <code>name</code> describes the name of the query parameter, the <code>value</code> the string which should change every build.
If the <code>value</code> is empty, no parameters are applied (e.g. in development mode). The <code>types</code> are file-types
which you want to be cache-busted. Split them with a semicolon.</p>
<p>To generate a short unique string for each build you can fill <code>bustValue</code> like this:</p>
<pre><code class="language-js">bustValue = require(&quot;randomstring&quot;).generate(5);
</code></pre>
<p>You then can see your result in the Network tab of your browser:</p>
<p><img src="./posts/2017/01/cache-busting-with-webpack/network-tab.jpg" alt="network-tab"></p>
</body></html>]]></description>
			<link>https://code-chris.github.io/posts/2017/01/cache-busting-with-webpack/index.html</link>
			<guid isPermaLink="false">Sun Jan 22 2017 15:05:00 GMT+0000 (UTC)-Cache-Busting with Webpack</guid>
			<dc:creator><![CDATA[Christian Kotzbauer]]></dc:creator>
			<pubDate>Sun, 22 Jan 2017 15:05:00 GMT</pubDate>
		</item>
		<item>
			<title><![CDATA[Long-term caching of Webpack Assets]]></title>
			<description><![CDATA[<html><head></head><body>


<p>If you want to use a solid long-term caching in your web application with Webpack then you have to do a lot of work.
Especially if you are not using the normal setup ;). With &quot;normal setup&quot; I mean that you use html- and css-loaders for
your HTML and CSS files so Webpack would interpret references to external files and include them in the final distribution.
This is nice because file renamings during the build process (for example add some chunkhash to the filename) will
be reflected back to the source code automatically.</p>
<p>But if you load these files with the raw-loader Webpack would ignore these references. So you have to ensure by yourself
that these files are available at runtime (that&apos;s the simple part). And you have to ensure that renamings are handled correctly.</p>
<p>So you need a logic, which can do this path modifications for you. Here is it: The <strong>static-asset-hash-replace-webpack-plugin</strong>.</p>
<p>The name is a little bit cumbersome, but it&apos;s easy to use:</p>
<p>Install the plugin with</p>
<pre><code>npm install static-asset-hash-replace-webpack-plugin
</code></pre>
<p>and extend your <code>webpack.config.js</code>:</p>
<pre><code>var StaticAssetHashReplace = require(&apos;static-asset-hash-replace-webpack-plugin&apos;);

module.exports = {
  ...
  plugins: [
    new StaticAssetHashReplace()
  ]
  ...
};
</code></pre>
<p>This will search and replace all occurrences of file references in your bundled assets. An example:</p>
<ul>
<li>&quot;../images/button.png&quot; =&gt; &quot;../images/button.46e48ce0628835f68a73.png&quot;</li>
<li>&quot;../images/icon.png&quot; =&gt; &quot;../images/46e48ce0628835f68a73-icon.png&quot;</li>
</ul>
<p>So now you can build your own long-term caching solution with all files you want to ship including static ones.</p>
</body></html>]]></description>
			<link>https://code-chris.github.io/posts/2016/10/long-term-caching-of-webpack-assets/index.html</link>
			<guid isPermaLink="false">Mon Oct 31 2016 18:00:00 GMT+0000 (UTC)-Long-term caching of Webpack Assets</guid>
			<dc:creator><![CDATA[Christian Kotzbauer]]></dc:creator>
			<pubDate>Mon, 31 Oct 2016 18:00:00 GMT</pubDate>
		</item>
		<item>
			<title><![CDATA[Migrating from Durandal to Aurelia]]></title>
			<description><![CDATA[<html><head></head><body>


<p>If you have an existing Durandal application you maybe want to migrate this app to Aurelia. Typically you used
Knockout for data-binding. Because Aurelia brings its own data-binding language the usage of Knockout
is not necessary anymore. But probably especially this part of the migration requires the greatest effort,
because you have to modify much of your code or partially rewrite it. So let&apos;s split this effort as much as possible:</p>
<p>Here&apos;s a way how you can use Aurelia side by side with the Knockout technology and then migrate each view and
view-model after another. You can use your old Knockout views and their backed JavaScript code with its observables
and subscriptions, as if you were still using Durandal.</p>
<h2>First Steps</h2>
<p>First, install the Aurelia plugin</p>
<pre><code>jspm install aurelia-knockout
</code></pre>
<p>and register it during the startup of your app:</p>
<pre><code>export function configure(aurelia) =&gt; {
    aurelia.use
        .standardConfiguration()
        .developmentLogging()
        .plugin(&quot;aurelia-knockout&quot;);

    aurelia.start().then(() =&gt; aurelia.setRoot());
}
</code></pre>
<p>The next step will be, to add the <code>knockout</code> custom attribute to each view which uses Knockout syntax:</p>
<pre><code>&lt;template&gt;
    &lt;div knockout&gt;
        &lt;button data-bind=&quot;click: changeVisibility&quot;&gt;Change Visibility&lt;/button&gt;
        &lt;div data-bind=&quot;if: isVisible&quot;&gt;
            &lt;span data-bind=&quot;text: firstName&quot;&gt;&lt;/span&gt;
            &lt;br/&gt;
            &lt;span data-bind=&quot;text: lastName&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>Note: The element with the custom attribute has to wrap all code with Knockout syntax.</p>
<p>This attribute binds the HTML to the current BindingContext of Aurelia.</p>
<p>And that&apos;s it! With these small modifications you can use all Knockout bindings which are available.</p>
<h2>Using Compositions</h2>
<p>Durandal also provided a binding to compose views. Because this binding was implemented from Durandal and not
from Knockout you can not use this feature natively. But the <code>aurelia-knockout</code> plugin supports the composition
with all possible variants listed in the <a href="http://durandaljs.com/documentation/Using-Composition.html">official Durandal docs</a>:</p>
<pre><code>&lt;div data-bind=&quot;compose: &apos;path/to/view.html&apos;&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: &apos;path/to/module&apos;&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: { view: &apos;path/to/view.html&apos; }&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: { model: &apos;path/to/module&apos; }&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: { model: moduleInstance }&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: { view: &apos;path/to/view.html&apos; model: &apos;path/to/module&apos; }&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: { view: &apos;path/to/view.html&apos; model: moduleInstance }&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: moduleInstance&quot;&gt;&lt;/div&gt;
&lt;div data-bind=&quot;compose: moduleConstructorFunction&quot;&gt;&lt;/div&gt;
</code></pre>
<h2>Set @bindable properties</h2>
<p>To enhance the flexibility of your migration process, this plugin also supports the ability to set <code>@bindable</code>
variables in rewritten subordinated Aurelia views through the activationData. This offers the possibility to rewrite
single views in lower hierarchies without the need to do the same with their parent views.</p>
<h5>Parent Knockout based view</h5>
<p>Supposed that there is a parent view using Knockout technology which composes a child view like this:</p>
<pre><code>&lt;template&gt;
  &lt;div data-bind=&quot;compose: { model: &apos;path/to/submodule&apos;, activationData: data }&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>The appropriate data object would looks like this:</p>
<pre><code>{
  price: ko.observable(5),
  productName: &quot;Apples&quot;
}
</code></pre>
<h5>Child Aurelia based view</h5>
<p>The child view and view-model uses Aurelia:</p>
<pre><code>&lt;template&gt;
  Product: &lt;span&gt;${productName}&lt;/span&gt;
  &lt;br/&gt;
  Price: &lt;span&gt;${price}&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<pre><code>import {bindable} from &quot;aurelia-framework&quot;;
import {inject} from &apos;aurelia-dependency-injection&apos;;
import {KnockoutBindable} from &quot;aurelia-knockout&quot;;

@inject(KnockoutBindable)
export class ProductView {

    @bindable
    price;
    productName;

    knockoutBindable;

    constructor(knockoutBindable) {
        this.knockoutBindable = knockoutBindable;
    }

    activate(activationData) {
        this.knockoutBindable.applyBindableValues(activationData, this);
    }
}
</code></pre>
<p>This will set the value from <code>activationData.price</code> to <code>this.price</code>. <code>this.productName</code> however, is not
updated because it has no <code>@bindable</code> decorator and the variable from <code>activationData</code> is no Knockout
observable. To process non Knockout observables anyway you have to pass <code>false</code> as third parameter to the
<code>applyBindableValues</code> function. If the outer value changed (and is an observable) the corresponding inner
variable is updated too.</p>
<p>Subscriptions for Knockout observables which are created from this plugin internally will be disposed automatically
if the child view is unbound.</p>
<p>As you can see, the migration to a new framework can be a big task depending on your application. But that does not
mean that you have to implement it all at once.</p>
</body></html>]]></description>
			<link>https://code-chris.github.io/posts/2016/06/migrating-from-durandal-to-aurelia/index.html</link>
			<guid isPermaLink="false">Wed Jun 15 2016 18:45:00 GMT+0000 (UTC)-Migrating from Durandal to Aurelia</guid>
			<dc:creator><![CDATA[Christian Kotzbauer]]></dc:creator>
			<pubDate>Wed, 15 Jun 2016 18:45:00 GMT</pubDate>
		</item>
		<item>
			<title><![CDATA[Pluggable NPM postprocessing]]></title>
			<description><![CDATA[<html><head></head><body>


<p>Have you ever had the situation that you installed npm packages and have to perform many manual steps after that?
Me too! Each step can be very easy, like copying files from one folder to another. But it worries and is error-prone.</p>
<p>One way around this problem can be to use other package managers which can do some of this tasks out of the box.
JSPM is one example for this. In some cases this would work and you can feel happy with that solution. But I assert
that in the most projects this is too unflexible. If you change something in your project&apos;s architecture or its tooling
you want that this part of your infrastructure can also adjust with. What we need is a flexible and pluggable solution.</p>
<p>So I&apos;ve started the <strong>NCMP</strong> project. The <strong>N</strong>ode <strong>C</strong>lient <strong>M</strong>odules <strong>P</strong>ostprocessor.</p>
<p>&quot;Client&quot; because the project is mainly aimed at client-side Web applications, but can in principle also be
used in other technology worlds.</p>
<p>Link to the <a href="https://github.com/ncmp">GitHub Organization</a>.</p>
<h2>The Basics</h2>
<p>The entry point of all is the ncmp package, which manages the config and provides a command-line interface. The
configuration file <code>ncmp.json</code> stores the node modules you want to process and configures the subsequent plugin
chain. Let&apos;s have a look:</p>
<pre><code>{
    &quot;packages&quot;: {
        &quot;jquery&quot;: [&quot;dist/jquery.js&quot;, &quot;dist/jquery.min.js&quot;],
        &quot;aurelia-framework&quot;: &quot;dist/amd/aurelia-framework.js&quot;,
        &quot;aurelia-templating&quot;: &quot;dist/amd/aurelia-templating.js&quot;
    },
    &quot;ignore&quot;: [
        &quot;bootstrap&quot;
    ],
    &quot;plugins&quot;: []
}
</code></pre>
<p>In this example you want to process the modules &quot;jquery&quot;, &quot;aurelia-framework&quot;, &quot;aurelia-templating&quot; and want to ignore
&quot;bootstrap&quot;. The files, which are mapped to the module name are the ones which should be processed. So generally the
main framework files. To create this configuration file simply use the following command: <code>ncmp init</code>.
This creates the file in your current working directory with the default values.</p>
<p>If you install or uninstall npm packages in your project you do not want to edit this configuration file by hand
every time. Because there is no way in npm to listen to a postinstall event for dependencies I have to write
a standalone command: <code>ncmp scan</code></p>
<p>This compares the listed packages from the <code>dependencies</code> section in your <code>package.json</code> with the <code>package</code>
section in the <code>ncmp.json</code>. Uninstalled packages will be removed. For new installed packages you will be asked
what you want to do:</p>
<p><img src="./posts/2016/04/pluggable-npm-postprocessing/scan-prompt.jpg" alt="scan-prompt"></p>
<p>Press ...</p>
<ul>
<li>enter to accept the shown package file.</li>
<li>&apos;i&apos; to ignore this package.</li>
</ul>
<p>To avoid this prompts you can run the command with the <code>-s</code> or <code>--silent</code> option. Then the installed packages
will be automatically accepted.</p>
<p>If you have configured your ncmp instance correctly you want to perform the postprocessing. To be consistent with
most other tools this command is named <code>install</code>. All configured plugins will be executed in a chain.</p>
<h2>The Plugins</h2>
<h3>Copy Files</h3>
<p>To copy files from one folder to another you have to use the <code>ncmp-copy-plugin</code>:</p>
<pre><code>{
    &quot;packages&quot;: {
        &quot;jquery&quot;: [&quot;dist/jquery.js&quot;, &quot;dist/jquery.min.js&quot;],
        &quot;aurelia-framework&quot;: &quot;dist/amd/aurelia-framework.js&quot;,
        &quot;aurelia-templating&quot;: &quot;dist/amd/aurelia-templating.js&quot;
    },
    &quot;destinations&quot;: {
        &quot;*.css&quot;: &quot;content/components&quot;,
        &quot;aurelia-*.js&quot;: &quot;scripts/components/aurelia/*&quot;,
        &quot;*&quot;: &quot;scripts/components&quot;,
    },
    &quot;ignore&quot;: [
        &quot;bootstrap&quot;
    ],
    &quot;plugins&quot;: [&quot;copy&quot;]
}
</code></pre>
<p>The listed files in &quot;packages&quot; are copied to the matching folder under &quot;destinations&quot;. So you have the ability to split
your files after your own conditions. As you can see, you can use globs at any place in the path.</p>
<h3>Module Loading with SystemJS</h3>
<p>If your web page uses SystemJS as module loader you have to maintain a additional configuration file. The ncmp plugin
<code>ncmp-systemjs-plugin</code> can automatically extend the existing paths to your libraries:</p>
<pre><code>{
    &quot;packages&quot;: {
        &quot;jquery&quot;: [&quot;dist/jquery.js&quot;, &quot;dist/jquery.min.js&quot;],
        &quot;aurelia-framework&quot;: &quot;dist/amd/aurelia-framework.js&quot;,
        &quot;aurelia-templating&quot;: &quot;dist/amd/aurelia-templating.js&quot;
    },
    &quot;destinations&quot;: {
        &quot;*.css&quot;: &quot;content/components&quot;,
        &quot;aurelia-*.js&quot;: &quot;scripts/components/aurelia/*&quot;,
        &quot;*&quot;: &quot;scripts/components&quot;,
    },
    &quot;moduleloaders&quot;: {
        &quot;systemjs&quot;: &quot;config.js&quot;
    },
    &quot;ignore&quot;: [
        &quot;bootstrap&quot;
    ],
    &quot;plugins&quot;: [&quot;copy&quot;, &quot;systemjs&quot;]
}
</code></pre>
<p>The only thing you have to configure in your <code>ncmp.json</code> is the plugin and the new &quot;moduleloaders&quot; section.
You have to map &quot;systemjs&quot; to the configuration file relative to your project&apos;s root directory. NCMP will modify
your <code>config.js</code> as following:</p>
<pre><code>System.config({
    baseDir: &quot;.&quot;,
    defaultJSExtensions: true,
    paths: {
        &quot;aurelia-framework&quot;: &quot;scripts/components/aurelia/framework/aurelia-framework&quot;,
        &quot;aurelia-templating&quot;: &quot;scripts/components/aurelia/templating/aurelia-templating&quot;,
        &quot;jquery&quot;: &quot;scripts/components/jquery&quot;
    }
});
</code></pre>
<p>The values from &quot;baseDir&quot; and &quot;defaultJSExtensions&quot; are respected as well.</p>
<h3>Module Loading with RequireJS</h3>
<p>The same thing for the RequireJS module loader:</p>
<pre><code>&quot;moduleloaders&quot;: {
    &quot;requirejs&quot;: &quot;requireconfig.js&quot;
},
&quot;plugins&quot;: [
    &quot;copy&quot;, &quot;requirejs&quot;
]
</code></pre>
<p>The result is similar to SystemJS.</p>
<h2>Forecast</h2>
<p>There are planned additional plugins for TypeScript Definitions or URL-Rewriting in CSS. The core package itself
should preserve an API to access it within a NodeJS-Script.</p>
</body></html>]]></description>
			<link>https://code-chris.github.io/posts/2016/04/pluggable-npm-postprocessing/index.html</link>
			<guid isPermaLink="false">Tue Apr 26 2016 20:33:00 GMT+0000 (UTC)-Pluggable NPM postprocessing</guid>
			<dc:creator><![CDATA[Christian Kotzbauer]]></dc:creator>
			<pubDate>Tue, 26 Apr 2016 20:33:00 GMT</pubDate>
		</item>
	</channel>
</rss>